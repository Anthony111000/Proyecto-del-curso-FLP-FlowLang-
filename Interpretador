#lang eopl

;------------------- Integrantes y repositorio ------------------

;Jhon Antony Murillo Olave – 2240927
;Jerson Alexis Ortiz Velasco – 2410014

;Repositorio: https://github.com/Anthony111000/Proyecto-del-curso-FLP-FlowLang-.git


#lang eopl

;----------------- Especificacion lexica y sintactica ----------------

;----------Gramatica BNF

; 
; ; <programa> :=  <expresion>
; ;                un-programa (exp)
; ; 
; ; 
; ; <expresion> := <numero>
; ;                numero-lit (num) 
; ;
; ;             := <complejo>
; ;                complejo-lit (real imag)
; ; 
; ;             := "\"" cadena "\""
; ;                cadena-lit (txt)
; 
; ;             := <null-exp>
; ;                null-exp ()
; ;
; ;		          := <false>
; ;                false-exp (false)
; ;
; ;             := <true>
; ;                true-exp (true)
; ; 
; ;             := <identificador>
; ;                var-exp (id)
; ;
; ;             := “var” “(“ (<identificador> “=” <expresion> “;”)+ “)” “{“ <expresion> “}”
; ;	               var-decl-exp (ids exps body)
; ;
; ;             := “set” <identificador> “=” <expresion>
; ;                set-exp (id exp)
; ;
; ;             := “const” “(“ (<identificador> “=” <expresion> “;”)+ “)” “{“ <expresion> “}”
; ;	                const-decl-exp (ids exps body)
; ;
; ;
; ;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DEFINICIONS E INVOCACIONES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;             := "procedimiento" (<identificador>*',') "haga" <expresion> "finProc"
; ;                func-exp (ids cuerpo)
; ;
; ;             := "func-rec" (<identificador> “(“ (<identificador> “,”)+ “)” “=” <expresion> “en” <expresion>
; ;                rec-exp (ids exps cuerpo)
; ;
; ;             := "evaluar" expresion (expresion ",")* "finEval"
; ;                app-exp (exp exps)  
; ;
; ;
; ;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATOS PREDEFINIDOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;		          := “list” ( <expresion>* “,”)
; ;                list-exp (exps)
; ;
; ;
; ;		          := “dict” ( (<identificador> : <expresion>)* “,” )
; ;                 dict-exp (exps)
; ;
; ;             := "prototipo" <identificador> "=" <expresion>
; ;                prototype-exp (id exp)
; ;
; ;
; ;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ESTRUCTURAS DE CONTROL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;             := "Si" <expresion> "entonces" <expresion> "sino" <expresion> "finSI"
; ;                condicional-exp (test-exp true-exp false-exp)
; ; 
; ;             := “begin” <expresion>+ “,” “end”
; ;                 begin-exp (exps)
; ;                
; ; 	          := “while” <expresion> “do” <expresion> “done”
; ;                while-exp (bool exp)
; ;
; ; 	          := “for” <identificador> “=” <expresion> “to” <expresion> “do” <expresion> “done” 
; ;	               for-exp (id exp1 exp2 exp3)
; ;
; ;
; ;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; EXPRESIONES DE PRIMITIVAS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ; 	          := “[“ <expresion> <pred-prim>  <expresion> “]”
; ;                pred-prim-exp (op1 prim op2)
; ;
; ;		          := “not“ <expresion> oper-un-bool(exp)
; ; 	                  <pred-prim>  := > (pred-bigger)
; ;		                       := <  pred-minor
; ;		                       := >=  pred-bigger-equal
; ;		                       := <=  pred-minor-equal
; ;		                       := ==  pred-equal
; ;		                       := !=  pred-not-equal
; ;		                       := and pred-and
; ;		                       := or pred-or
; ;
; ; 	          := <primitiva-sin-arg> primapp-sin-arg-exp (prim)
; ;	               <primitiva-sin-arg> := vacio primitiva-vacio
; ;
; ; 	          := <primitiva-unaria> (<expresion>) primapp-un-exp (prim exp)
; ;	               <primitiva-unaria> := longitud primitiva-longitud
; ;	                                    := add1 primitiva-add1
; ;	                                    := sub1 primitiva-sub1
; ;	                                    := vacio? primitiva-es-vacio
; ;	                                    := lista? primitiva-es-lista
; ;	                                    := cabeza primitiva-cabeza
; ;	                                    := cola primitiva-cola
; ;	                                    := print primitiva-print
; ;	                                    := dict? primitiva-is-dict
; ;
; ; 	          := <primitiva-binaria> (<expresion> , <expresion>) primapp-bin-exp (prim exp1 exp2)
; ;	               <primitiva-binaria> := + primitiva-suma
; ;	                                     := ~ primitiva-resta
; ;	                                     := / primitiva-div
; ;	                                     := * primitiva-multi
; ;	                                     := mod primitiva-mod
; ;	                                     := concat primitiva-concat
; ;	                                     := append primitiva-append
; ;	                                     := crear-lista primitiva-crear-lista
; ;
; ;             := <primitiva-dict-unaria> ( <expresion> ) primapp-un-dict-exp (prim exp)
; ;                <primitiva-dict-unaria> := claves-dict (primitiva-claves-dict)
; ;				                                          := valores-dict (primitiva-valores-dict)
; ;
; ;		          := <primitiva-dict-bin> ( <expresion> , <identificador> ) primaapp-bin-dict-exp (prim exp id)
; ;                <primitiva-dict-bin> := ref-dict (primitiva-bin-dict)
; ;
; ;		          := <primitiva-dict-ter> ( <expresion> , <identificador> , <expresion>) primaapp-ter-dict-exp (prim exp1 id exp2)
; ;                <primitiva-dict-ter> := crear-dict (primitiva-crear-dict)
; ; 				                                     := set-dict (primitiva-set-dict)
; ;
; ;
; ;
;---------- Especificacion lexica ------------------------------------------------------------------
(define scanner-spec-flowlang
'((white-sp
   (whitespace) skip)
  (comment
   ("//" (arbno (not #\newline))) skip)
  (identificador
   ("@" letter (arbno (or letter digit "?"))) symbol)
  (numero
   (digit (arbno digit)) number)
  (numero
   ("-" digit (arbno digit)) number)
  (numero
   (digit (arbno digit) "." digit (arbno digit)) number)
  (numero
   ("-" digit (arbno digit) "." digit (arbno digit)) number)
  (complejo
   (digit "+" digit "i") symbol)
  (complejo
   (digit "-" digit "i") symbol)
  (complejo
   ("-" digit "+" digit "i") symbol)
  (complejo
   ("-" digit "-" digit "i") symbol)
  (texto
   (letter (arbno (or letter digit "-" ":"))) string); 
  (null-keyword 
   ("null") symbol)
))




;----------Especificacion sintactica
(define grammar-flowlang
  '((programa (expresion) un-programa)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (expresion (numero) numero-lit)

    (expresion (complejo) complejo-lit)
    
    (expresion ("\"" texto "\"") cadena-lit)

    (expresion ("null") null-exp)





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DEFINICIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;; INDENTIFICADORES ;;;;;;;;;;;;;;;;
    (expresion (identificador) var-exp)

    ;;;;;;;;;;;;;;;; VAR ;;;;;;;;;;;;;;;;
    (expresion ("var" "(" (separated-list identificador "=" expresion ";") ")" "{" expresion "}")
               var-decl-exp)

    ;;;;;;;;;;;;;;;; SET ;;;;;;;;;;;;;;;;
    (expresion ("set" identificador "=" expresion)
               set-exp)
    
    ;;;;;;;;;;;;;;;; CONST ;;;;;;;;;;;;;;;;
    (expresion ("const" "(" (separated-list identificador "=" expresion ";") ")" "{" expresion "}")
                const-decl-exp)





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FUNCIONES E INVOCACIONES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;; Funciones ;;;;;;;;;;;;;;;;
    (expresion ("func" "("(separated-list identificador ",")")" "{" expresion "}")
               func-exp(ids cuerpo))

    ;;;;;;;;;;;;;;;; Recursivas ;;;;;;;;;;;;;;;;
    (expresion ("func-rec" "(" (arbno identificador "(" (separated-list identificador ",") ")" "=" expresion) ")"  "{" expresion "}")
                rec-exp)

    ;;;;;;;;;;;;;;;; Invocar ;;;;;;;;;;;;;;;;
    (expresion ("evaluar" expresion "("(separated-list expresion ",")")" "finEval")
               app-exp(exp exps))





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATOS PREDEFINIDOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;; Listas ;;;;;;;;;;;;;;;;
    (expresion ("list" "("(separated-list expresion ",") ")")
               list-exp(exps))

    ;;;;;;;;;;;;;;;; Diccionarios ;;;;;;;;;;;;;;;;
    (expresion ("dict" "("(separated-list identificador ":" expresion ",") ")")
               dict-exp(exps))





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ESTRUCTURAS DE CONTROL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;; IF ;;;;;;;;;;;;;;;;
    (expresion ("if" expresion "then" expresion "else" expresion "done")
               condicional-exp)

    ;;;;;;;;;;;;;;;; While ;;;;;;;;;;;;;;;;
    (expresion ("while" expresion "do" expresion "done")
               while-exp)
    
    ;;;;;;;;;;;;;;;; For ;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;; For unificado ;;;;;;;;;;;;;;;;
    (expresion ("for" identificador for-operator expresion "do" expresion "done")
           for-exp)
           (for-operator ("=" "to") for-num-operator)
           (for-operator ("in") for-in-operator)

    ;;;;;;;;;;;;;;;; Begin ;;;;;;;;;;;;;;;;
    (expresion ("begin" expresion (arbno ";" expresion) "end")
                begin-exp)





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BOOLENANOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;; False ;;;;;;;;;;;;;;;;
    (expresion ("false")
               false-exp)
    
    ;;;;;;;;;;;;;;;; True ;;;;;;;;;;;;;;;;
    (expresion ("true")
               true-exp)

    ;;;;;;;;;;;;;;;; Not ;;;;;;;;;;;;;;;;
    (expresion ("not" expresion)
              oper-un-bool)
    
    ;;;;;;;;;;;;;;;; Primitivas Booleanas ;;;;;;;;;;;;;;;;
    (expresion ("[" expresion pred-prim expresion "]" )
               pred-prim-exp)
              (pred-prim (">")   pred-bigger)
              (pred-prim ("<")   pred-minor)
              (pred-prim (">=")  pred-bigger-equal)
              (pred-prim ("<=")  pred-minor-equal)
              (pred-prim ("==")  pred-equal)
              (pred-prim ("!=")  pred-not-equal)
              (pred-prim ("and") pred-and)
              (pred-prim ("or")  pred-or)





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PRIMITIVAS GENERALES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SIN ARGUMENTO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (expresion (primitiva-sin-arg)
               primapp-sin-arg-exp)
              (primitiva-sin-arg ("vacio") primitiva-vacio)


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; UNARIAS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (expresion (primitiva-unaria "(" expresion ")" )
               primapp-un-exp)
              (primitiva-unaria ("longitud") primitiva-longitud)
              (primitiva-unaria ("add1") primitiva-add1)
              (primitiva-unaria ("sub1") primitiva-sub1)
              (primitiva-unaria ("vacio?") primitiva-es-vacio)
              (primitiva-unaria ("lista?") primitiva-es-lista)
              (primitiva-unaria ("cabeza") primitiva-cabeza)
              (primitiva-unaria ("cola") primitiva-cola)
              (primitiva-unaria ("print") primitiva-print)
              (primitiva-unaria ("dict?") primitiva-is-dict)


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;BINARIAS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (expresion (primitiva-binaria "(" expresion "," expresion ")" )
               primapp-bin-exp)
              (primitiva-binaria ("+") primitiva-suma)
              (primitiva-binaria ("~") primitiva-resta)
              (primitiva-binaria ("/") primitiva-div)
              (primitiva-binaria ("*") primitiva-multi)
              (primitiva-binaria ("mod") primitiva-mod)
              (primitiva-binaria ("concat") primitiva-concat)
              (primitiva-binaria ("append") primitiva-append)
              (primitiva-binaria ("crear-lista") primitiva-crear-lista)
              (primitiva-binaria ("ref-list") primitiva-ref-list)
              ;;;;;;;;;;;;; operaciones osbre compljos
              (primitiva-binaria ("complejo+") primitiva-complejo-suma)
              (primitiva-binaria ("complejo-") primitiva-complejo-resta)
              (primitiva-binaria ("complejo*") primitiva-complejo-multi)
              (primitiva-binaria ("complejo/") primitiva-complejo-div)


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Ternarias;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (expresion (primitiva-ternaria "(" expresion "," expresion "," expresion ")" )
              primapp-ter-exp)
              (primitiva-ternaria ("set-list") primitiva-set-list)





    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PRIMITIVAS DICCIONARIOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;; Expresion primitivas unarias ;;;;;;;;;;;;;;;;
    (expresion (primitiva-dict-unaria "(" expresion ")" )
               primapp-un-dict-exp)
              (primitiva-dict-unaria ("claves-dict") primitiva-claves-dict)
              (primitiva-dict-unaria ("valores-dict") primitiva-valores-dict)


    ;;;;;;;;;;;;;;;; Expresion primitivas binarias ;;;;;;;;;;;;;;;;
    (expresion (primitiva-dict-bin "("  expresion ","identificador ")" )
               primaapp-bin-dict-exp)
              (primitiva-dict-bin ("ref-dict") primitiva-ref-dict)


    ;;;;;;;;;;;;;;;; Expresion primitivas ternarias ;;;;;;;;;;;;;;;;
    (expresion (primitiva-dict-ter "(" expresion "," identificador "," expresion ")" )
               primaapp-ter-dict-exp)
              (primitiva-dict-ter ("crear-dict") primitiva-crear-dict)
              (primitiva-dict-ter ("set-dict") primitiva-set-dict)
))



;----------------------- Implementacion ----------------------
;----------Tipos de datos
(sllgen:make-define-datatypes scanner-spec-flowlang grammar-flowlang)
(define show-the-datatypes
  (lambda ()
    (sllgen:list-define-datatypes scanner-spec-flowlang grammar-flowlang)))

;----------Funciones scan&parse, just-scan e interpretador
;FrontEnd (Análisis léxico (scanner) y sintáctico (parser) integrados)
(define scan&parse
  (sllgen:make-string-parser scanner-spec-flowlang grammar-flowlang))


;Analizador Léxico (Scanner)
(define just-scan
  (sllgen:make-string-scanner scanner-spec-flowlang grammar-flowlang))


;Interpretador (FrontEnd + Evaluación + señal para lectura)
(define interpretador
  (sllgen:make-rep-loop  "--> "
    (lambda (pgm) (evaluar-programa  pgm)) 
    (sllgen:make-stream-parser 
      scanner-spec-flowlang
      grammar-flowlang)))



;-----------------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------------
;Evaluar programa y expresiones
;evaluar-programa : <programa> -> numero
;Función que evalúa un programa teniendo en cuenta un ambiente dado (se inicializa dentro del programa)
(define evaluar-programa
  (lambda (pgm)
    (cases programa pgm
      (un-programa (expresion)
                   (evaluar-expresion expresion (ambiente-inicial))))))



;evaluar-expresion: <expresion> <ambiente> -> numero
;Evalua la expresión en el ambiente de entrada
(define evaluar-expresion
  (lambda (exp amb)
    (cases expresion exp
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (numero-lit (numero) numero)

      (complejo-lit (complejo-str)
        (parse-complejo complejo-str))

      (cadena-lit (cadena) cadena)

      (null-exp () 'null)




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DEFINICIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
      ;;;;;;;;;; Identificadores ;;;;;;;;;; 
      (var-exp (id) (buscar-variable id amb))

      ;;;;;;;;;; Var ;;;;;;;;;;
      (var-decl-exp(ids exps cuerpo)
                        (let ((args (evaluar-operandos exps amb)))
                          (evaluar-expresion cuerpo (ambiente-extendido ids args amb))
                        ))

      ;;;;;;;;;; Set ;;;;;;;;;;
      (set-exp (id rhs-exp)
               (begin
                 (cond
                   [(buscar-variable-const id variables-constantes)
                    (eopl:error 'evaluar-expresion
                                 "No es posible modificar una variable constante" )]
                   [else (setref!
                          (buscar-variable-ref id amb)
                          (evaluar-expresion rhs-exp amb))
                   ])
                 1))

      ;;;;;;;;;; Const ;;;;;;;;;;
      (const-decl-exp(ids exps cuerpo)
                        (begin
                          (set! variables-constantes (append variables-constantes ids))
                          (let ((args (evaluar-operandos exps amb)))
                          (evaluar-expresion cuerpo (ambiente-extendido ids args amb)))
                        ))




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  FUNCIONES E INVOCACIONES  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
      ;;;;;;;;;; funciones ;;;;;;;;;; 
      (func-exp (ids cuerpo)
                         (cerradura ids cuerpo amb))

      ;;;;;;;;;; recursivas ;;;;;;;;;;
      (rec-exp (nombre-proc idss cuerpo letrec-cuerpo)
                  (evaluar-expresion letrec-cuerpo
                                   (ambiente-extendido-recursivo nombre-proc idss cuerpo amb)
                  ))

      ;;;;;;;;;; invocar ;;;;;;;;;;
      (app-exp (exp exps)
               (let ((proc (evaluar-expresion exp amb))
                    (args (evaluar-operandos exps amb)))
                 (if (procVal? proc)
                     (aplicar-procedimiento proc args)
                     (eopl:error 'evaluar-expresion
                                  "Attempt to apply non-procedure ~s" proc))
               ))




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATOS PREDEFINIDOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
      ;;;;;;;;;; listas ;;;;;;;;;;
      (list-exp (exps)
                    (evaluar-operandos exps amb))

      ;;;;;;;;;; Diccionario ;;;;;;;;;;
      (dict-exp (ids exps)
                    (let(( rand (evaluar-operandos exps amb)))
                        (list (list->vector ids) (list->vector rand))
                    ))




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ESTRUCTURAS DE CONTROL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
      ;;;;;;;;;; IF ;;;;;;;;;;
      (condicional-exp (test-exp true-exp false-exp)
                       (if (valor-verdad? (evaluar-expresion test-exp amb))
                           (evaluar-expresion true-exp amb)
                           (evaluar-expresion false-exp amb)
                       ))

      ;;;;;;;;;; WHILE ;;;;;;;;;;
      (while-exp (bool-exp exp)
                  (let loop ((i 0))
                   (when (valor-verdad? (evaluar-expresion bool-exp amb))
                         (evaluar-expresion exp amb)
                         (loop (+ 1 i)))
                  ))

      ;;;;;;;;;;;;;;; FOR unificado ;;;;;;;;;;;;;;;;
      (for-exp (id operator range-exp body-exp)
        (cases for-operator operator
          (for-num-operator ()
            (let ((rango (evaluar-expresion range-exp amb)))
              (if (not (list? rango))
                  (eopl:error 'evaluar-expresion "Se esperaba una lista de [inicio, fin] en for numérico: ~s" rango)
                  (let ((ini (car rango))
                        (fin (cadr rango)))
                    (let loop ((i ini))
                      (when (<= i fin)
                        (evaluar-expresion body-exp (ambiente-extendido (list id) (list i) amb))
                        (loop (+ 1 i))))))))
    
          (for-in-operator ()
            (let ((lista (evaluar-expresion range-exp amb)))
              (if (not (list? lista))
                  (eopl:error 'evaluar-expresion "Se esperaba una lista en for-in: ~s" lista)
                  (let loop ((elementos lista))
                    (when (not (null? elementos))
                      (evaluar-expresion body-exp (ambiente-extendido (list id) (list (car elementos)) amb))
                      (loop (cdr elementos)))))))))


      ;;;;;;;;;; BEGIN ;;;;;;;;;;
      (begin-exp (exp exps) 
                 (let loop 
                    ((acc (evaluar-expresion exp amb))
                     (exps exps))
                    (if (null? exps) 
                        acc
                        (loop (evaluar-expresion (car exps) amb) (cdr exps)))
                 ))




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BOOLANEAS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;; false ;;;;;;;;;;
      (false-exp () #f)

      ;;;;;;;;;; true ;;;;;;;;;;
      (true-exp () #t)
      
      ;;;;;;;;;; Unarias ;;;;;;;;;;
      (oper-un-bool (pred) 
        (not (valor-verdad? (evaluar-expresion pred amb))))

      ;;;;;;;;;; primitivas booleanas ;;;;;;;;;;
      (pred-prim-exp (op1 pred-prim op2)
                (let ((args (evaluar-operandos (list op1 op2) amb)))
                    (aplicar-pred-prim pred-prim args)
                ))




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PRIMITIVAS GENERALES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;; sin argumentos ;;;;;;;;;;
      (primapp-sin-arg-exp (primitiva-sin-arg)
                           '())

      ;;;;;;;;;; unarias ;;;;;;;;;;
      (primapp-un-exp (primitiva-unaria op1)
                      (let ((arg (evaluar-operando op1 amb)))
                           (aplicar-primitiva-unaria primitiva-unaria arg)
                      ))

      ;;;;;;;;;; binarias ;;;;;;;;;;
      (primapp-bin-exp (primitiva-binaria op1 op2)
                       (let ((args (evaluar-operandos (list op1 op2) amb)))
                            (aplicar-primitiva-binaria primitiva-binaria args)
                        ))

      ;;;;;;;;;;;;;;;;; ternarias ;;;;;;;;;;;
      (primapp-ter-exp (primitiva-ternaria op1 op2 op3)
                      (let ((args (evaluar-operandos (list op1 op2 op3) amb)))
                            (aplicar-primitiva-ternaria primitiva-ternaria args)
                      ))




      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PRIMITIVAS DICCIONARIOS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;; unarias ;;;;;;;
      (primapp-un-dict-exp (prim-un-dict exp)
                               (let((arg (evaluar-operando exp amb)))
                                   (aplicar-primitiva-unaria-dict prim-un-dict arg)
                               ))

      ;;;;;; binarias ;;;;;;
      (primaapp-bin-dict-exp (prim-bin-dict dict id)
                               (let((arg1 (evaluar-operando dict amb)))
                                    (aplicar-primitiva-binaria-dict prim-bin-dict arg1 id)
                               ))

      ;;;;;; ternarias ;;;;;;
      (primaapp-ter-dict-exp (prim-ter-dict dict idc expc)
                               (let((arg1 (evaluar-operando dict amb))
                                    (arg2 (evaluar-operando expc amb)))
                                    (aplicar-primitiva-ternaria-dict prim-ter-dict (list arg1 idc arg2))
                               ))
)))


;-----------------------------------------------------------------------------------------------------

;Funciones auxiliares para aplicar evaluar-expresion a cada elemento de una lista de operandos (expresiones)
(define evaluar-operandos
  (lambda (rands env)
    (map (lambda (x) (evaluar-operando x env)) rands)))


(define evaluar-operando
  (lambda (rand env)
    (evaluar-expresion rand env)))

;-----------------------------------------------------------------------------------------------------
; Función auxiliar para determinar si un valor es "truthy" o "falsy"
(define valor-verdad?
  (lambda (valor)
    (cond
      ; Valores "falsy" según FlowLang:
      ((eqv? valor 'null) #f)        ; null es falso
      ((eqv? valor #f) #f)           ; false es falso
      ((and (number? valor) (zero? valor)) #f)  ; 0 es falso
      ((and (string? valor) (zero? (string-length valor))) #f)  ; cadena vacía es falsa
      ; Cualquier otro valor es "truthy"
      ((and (list? valor) (null? valor)) #f)    ; lista vacía es falsa
      (else #t))))


;-----------------------------------------------------------------------------------------------------
;aplicar-primitiva-unaria: <primitiva-unaria> <list-of-expresion> -> numero
;Obtiene el resultado de aplicar la primitiva unaria al operando
(define aplicar-primitiva-unaria
  (lambda (prim arg)
    (cases primitiva-unaria prim
      (primitiva-longitud  () (string-length arg))
      (primitiva-add1      () (+ arg 1))
      (primitiva-sub1      () (- arg 1))
      (primitiva-es-vacio  () (null? arg))
      (primitiva-es-lista  () (list? arg))
      (primitiva-cabeza    () (car arg))
      (primitiva-cola      () (cdr arg))
      (primitiva-print     () (begin (display arg) (newline)))
      (primitiva-is-dict    ()  (dict?  arg))
    )))
;-----------------------------------------------------------------------------------------------------


;-----------------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------------
; Funciones para números complejos

; Parsear string de complejo a lista (real imag)
; Versión final robusta de parse-complejo
(define parse-complejo
  (lambda (complejo-str)
    (let ((str (symbol->string complejo-str)))
      (let ((len (string-length str)))
        ; Verificar formato básico
        (if (or (< len 3) (not (char=? (string-ref str (- len 1)) #\i)))
            (eopl:error 'parse-complejo "Formato de número complejo inválido: ~s" complejo-str)
            (let ((without-i (substring str 0 (- len 1))))
              ; Manejar casos especiales primero
              (cond
                ; Caso: solo parte imaginaria (ej: "3i" se escribiría como "0+3i" en nuestro scanner)
                ((string-contains-char? without-i #\+)
                 (let ((parts (string-split without-i #\+)))
                   (if (= (length parts) 2)
                       (list (string->number (car parts)) (string->number (cadr parts)))
                       (eopl:error 'parse-complejo "Formato de complejo inválido: ~s" complejo-str))))
                ((string-contains-char? without-i #\-)
                 (let ((parts (string-split without-i #\-)))
                   (cond
                     ((= (length parts) 2)
                      (list (string->number (car parts)) (- (string->number (cadr parts)))))
                     ((= (length parts) 3) ; caso -a-bi
                      (list (- (string->number (cadr parts))) (- (string->number (caddr parts)))))
                     (else
                      (eopl:error 'parse-complejo "Formato de complejo inválido: ~s" complejo-str))))
                 (eopl:error 'parse-complejo "Formato de complejo inválido: ~s" complejo-str)))))))))

; Verificar si es un número complejo
(define complejo?
  (lambda (x)
    (and (list? x) 
         (= (length x) 2) 
         (number? (car x)) 
         (number? (cadr x)))))

; Operaciones con números complejos
(define suma-complejos
  (lambda (c1 c2)
    (if (and (complejo? c1) (complejo? c2))
        (list (+ (car c1) (car c2))
              (+ (cadr c1) (cadr c2)))
        (eopl:error 'suma-complejos "Argumentos no son complejos: ~s y ~s" c1 c2))))

(define resta-complejos
  (lambda (c1 c2)
    (if (and (complejo? c1) (complejo? c2))
        (list (- (car c1) (car c2))
              (- (cadr c1) (cadr c2)))
        (eopl:error 'resta-complejos "Argumentos no son complejos: ~s y ~s" c1 c2))))

(define multiplica-complejos
  (lambda (c1 c2)
    (if (and (complejo? c1) (complejo? c2))
        (let ((a (car c1))
              (b (cadr c1))
              (c (car c2))
              (d (cadr c2)))
          (list (- (* a c) (* b d))
                (+ (* a d) (* b c))))
        (eopl:error 'multiplica-complejos "Argumentos no son complejos: ~s y ~s" c1 c2))))

(define divide-complejos
  (lambda (c1 c2)
    (if (and (complejo? c1) (complejo? c2))
        (let ((a (car c1))
              (b (cadr c1))
              (c (car c2))
              (d (cadr c2)))
          (let ((denominador (+ (* c c) (* d d))))
            (if (zero? denominador)
                (eopl:error 'divide-complejos "División por cero en complejos")
                (list (/ (+ (* a c) (* b d)) denominador)
                      (/ (- (* b c) (* a d)) denominador)))))
        (eopl:error 'divide-complejos "Argumentos no son complejos: ~s y ~s" c1 c2))))


; Funciones auxiliares para manejar strings
(define string-split
  (lambda (str char)
    (let loop ((chars (string->list str))
               (current '())
               (result '()))
      (cond
        ((null? chars)
         (reverse (cons (list->string (reverse current)) result)))
        ((char=? (car chars) char)
         (loop (cdr chars) 
               '() 
               (cons (list->string (reverse current)) result)))
        (else
         (loop (cdr chars) 
               (cons (car chars) current) 
               result))))))

(define string-contains-char?
  (lambda (str ch)
    (let loop ((chars (string->list str)))
      (cond
        ((null? chars) #f)
        ((char=? (car chars) ch) #t)
        (else (loop (cdr chars)))))))
;-----------------------------------------------------------------------------------------------------

;-----------------------------------------------------------------------------------------------------
;aplicar-primitiva-binaria: <primitiva-binaria> <list-of-expresion> -> numero
;Obtiene el resultado de aplicar la primitiva binaria a los operandos
(define aplicar-primitiva-binaria
  (lambda (prim args)
    (cases primitiva-binaria prim
      (primitiva-suma   () (+ (car args) (cadr args)))
      (primitiva-resta  () (- (car args) (cadr args)))
      (primitiva-div    () (/ (car args) (cadr args)))
      (primitiva-multi  () (* (car args) (cadr args)))
      (primitiva-mod    () 
          (let ((dividendo (car args))
            (divisor (cadr args)))
          (if (zero? divisor)
            (eopl:error 'primitiva-mod "División por cero")
            (- dividendo (* divisor (truncate (/ dividendo divisor)))))))
      (primitiva-concat () (string-append (car args) (cadr args)))
      (primitiva-append () (append (car args) (cadr args)))
      (primitiva-crear-lista () (append (car args) (list(cadr args))))
      (primitiva-ref-list ()
        (let ((lst (car args))
              (index (cadr args)))
          ; Verificar que el índice sea un número entero
          (if (not (integer? index))
              (eopl:error 'aplicar-primitiva-binaria "El índice debe ser un número entero: ~s" index)
              
              ; Llamar a la función auxiliar para buscar en la lista
              (ref-list-aux lst index 0)
          )))

      ; Operaciones específicas para complejos
      (primitiva-complejo-suma () 
        (let ((arg1 (car args)) (arg2 (cadr args)))
          (if (and (complejo? arg1) (complejo? arg2))
              (suma-complejos arg1 arg2)
              (eopl:error 'primitiva-complejo-suma "Argumentos deben ser complejos: ~s y ~s" arg1 arg2))))
      
      (primitiva-complejo-resta () 
        (let ((arg1 (car args)) (arg2 (cadr args)))
          (if (and (complejo? arg1) (complejo? arg2))
              (resta-complejos arg1 arg2)
              (eopl:error 'primitiva-complejo-resta "Argumentos deben ser complejos: ~s y ~s" arg1 arg2))))
      
      (primitiva-complejo-multi () 
        (let ((arg1 (car args)) (arg2 (cadr args)))
          (if (and (complejo? arg1) (complejo? arg2))
              (multiplica-complejos arg1 arg2)
              (eopl:error 'primitiva-complejo-multi "Argumentos deben ser complejos: ~s y ~s" arg1 arg2))))
      
      (primitiva-complejo-div () 
        (let ((arg1 (car args)) (arg2 (cadr args)))
          (if (and (complejo? arg1) (complejo? arg2))
              (divide-complejos arg1 arg2)
              (eopl:error 'primitiva-complejo-div "Argumentos deben ser complejos: ~s y ~s" arg1 arg2))))
)))


; Función recursiva para buscar elemento en lista por índice
(define ref-list-aux
  (lambda (lst index current)
    (cond
      ; Caso 1: Lista vacía - índice inválido, retornar null
      ((null? lst) 'null)
      
      ; Caso 2: Encontró el índice - retornar el elemento
      ((= current index) (car lst))
      
      ; Caso 3: Seguir buscando recursivamente
      (else (ref-list-aux (cdr lst) index (+ current 1))))))

;-----------------------------------------------------------------------------------------------------


;aplicar-primitiva-ternaria: <primitiva-ternaria> <list-of-expresion> -> valor
(define aplicar-primitiva-ternaria
  (lambda (prim args)
    (cases primitiva-ternaria prim
      (primitiva-set-list ()
        (let ((lst (car args))
              (index (cadr args))
              (valor (caddr args)))
          ; Verificar que el índice sea un número entero
          (if (not (integer? index))
              (eopl:error 'aplicar-primitiva-ternaria "El índice debe ser un número entero: ~s" index)
              ; Llamar a la función auxiliar para modificar la lista
              (set-list-aux lst index valor 0)
          )))
      )))

; Función recursiva para modificar elemento en lista por índice
(define set-list-aux
  (lambda (lst index valor current)
    (cond
      ; Caso 1: Lista vacía - índice inválido
      ((null? lst)
       (eopl:error 'set-list-aux "Índice ~s fuera de rango para la lista: ~s" index lst))
      
      ; Caso 2: Encontró el índice - reemplazar el elemento
      ((= current index)
       (cons valor (cdr lst)))
      
      ; Caso 3: Seguir buscando recursivamente
      (else 
       (cons (car lst) (set-list-aux (cdr lst) index valor (+ current 1)))))))


;-----------------------------------------------------------------------------------------------------
;aplicar-primitiva-unaria-dict: <primitiva-unaria-dict> <list-of-expresion> -> vector
(define aplicar-primitiva-unaria-dict
  (lambda (prim arg)
    (cases primitiva-dict-unaria prim
      (primitiva-claves-dict () 
        (if (dict? arg)
            (vector->list (car arg))  ; Convertir vector de claves a lista
            (eopl:error 'aplicar-primitiva-unaria-dict "Se esperaba un diccionario: ~s" arg)))
      
      (primitiva-valores-dict () 
        (if (dict? arg)
            (vector->list (cadr arg))  ; Convertir vector de valores a lista
            (eopl:error 'aplicar-primitiva-unaria-dict "Se esperaba un diccionario: ~s" arg))))))



(define aplicar-primitiva-binaria-dict
  (lambda (prim dict clave)
    (cases primitiva-dict-bin prim
      (primitiva-ref-dict () 
        ; Verificar que el argumento sea un diccionario válido
        (if (not (dict? dict))
            (eopl:error 'aplicar-primitiva-binaria-dict "Se esperaba un diccionario: ~s" dict)
            ; Buscar la clave en el diccionario
            (ref-dict-aux dict clave)
        )
      )
   )))
 
 

; Función para buscar una clave en un diccionario
(define ref-dict-aux
  (lambda (dict clave)
    (let ((claves-vec (car dict))   ; Vector de claves
          (valores-vec (cadr dict))) ; Vector de valores
      
      ; Convertir vector de claves a lista para buscar
      (let ((claves-lst (vector->list claves-vec))
            (valores-lst (vector->list valores-vec)))
        
        ; Buscar la posición de la clave
        (let ((pos (list-find-position clave claves-lst)))
          (if (number? pos)
              ; Si encontramos la clave, devolver el valor correspondiente
              (list-ref valores-lst pos)
              ; Si no encontramos la clave, devolver null
              'null
          )))
    )))


;aplicar-primitiva-ternaria-dict: <primitiva-dict-ter> <list-of-expresion> -> vector
;Obtiene el resultado de aplicar la primitiva ternaria de diccionario a los operandos
(define aplicar-primitiva-ternaria-dict
  (lambda (prim args)
    (cases primitiva-dict-ter prim
      (primitiva-crear-dict () (define v1 (list->vector (append  (vector->list (caar args)) (list (cadr args))))) (define v2 (list->vector (append  (vector->list (cadar args)) (list (caddr args)))))(list v1 v2))
      (primitiva-set-dict ()(vector-set! (cadar args)(list-find-position (cadr args) (vector->list (caar args)))(caddr args)))
      )))
;-----------------------------------------------------------------------------------------------------




;-----------------------------------------------------------------------------------------------------
;aplicar predicado booleano
(define aplicar-pred-prim
  (lambda (prim args)
    (cases pred-prim prim
      (pred-bigger       () (> (car args) (cadr args)))
      (pred-minor        () (< (car args) (cadr args)))
      (pred-bigger-equal () (>= (car args) (cadr args)))
      (pred-minor-equal  () (<= (car args) (cadr args)))
      (pred-equal        () (equal? (car args) (cadr args)))
      (pred-not-equal    () (not (equal? (car args) (cadr args))))
      (pred-and          () (and (car args) (cadr args)))
      (pred-or           () (or (car args) (cadr args)))
      )))
;-----------------------------------------------------------------------------------------------------



;-----------------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------------
;----------Definiendo ambientes y un ambiente inicial
;Ambiente inicial
(define ambiente-inicial
  (lambda ()
    (ambiente-extendido
     '(@a @b @c @d @e)
      '(1 2 3 "Hola" "FLP" )
     (ambiente-vacio))))





;Definiendo ambientes
(define-datatype ambiente ambiente?
  (ambiente-vacio-ejecutado)
  (ambiente-extendido-ejecutado
   (syms (list-of symbol?))
   (vec vector?)
   (ambiente ambiente?)))
(define scheme-value? (lambda (v) #t))





;ambiente vacio:      -> ambiente
;Función que crea un ambiente vacío
(define ambiente-vacio 
  (lambda ()
    (ambiente-vacio-ejecutado)))




;ambiente-extendido: <list-of symbols> <list-of numbers> ambiente -> ambiente
;Función que crea un ambiente extendido
(define ambiente-extendido
  (lambda (syms vals env)
    (ambiente-extendido-ejecutado syms (list->vector vals) env)))





;----------Funcion buscar-variable
;buscar-variable: <identificador> <ambiente> -> scheme-value
;Funcion que busca una variable y retorna su valor (en caso de encontrarla) o un error (en caso de no encontrarla)
(define buscar-variable
  (lambda (id amb)
      (deref (buscar-variable-ref id amb))))

(define buscar-variable-ref
  (lambda (id amb)
    (cases ambiente amb
      (ambiente-vacio-ejecutado ()
                        (eopl:error 'apply-env-ref "No binding for ~s" id))
      (ambiente-extendido-ejecutado (ids vals amb)
                           (let ((pos (rib-find-position id ids)))
                             (if (number? pos)
                                 (a-ref pos vals)
                                 (buscar-variable-ref id amb)))))))

(define buscar-variable-const
  (lambda (elemento lista)
    (cond
      [(null? lista) #f]
      [else
       (if(eqv? (car lista) elemento) #t
          (buscar-variable-const elemento (cdr lista)))])))

(define rib-find-position 
  (lambda (sym los)
    (list-find-position sym los)))

(define ambiente-extendido-recursivo
  (lambda (proc-names idss bodies old-env)
    (let ((len (length proc-names)))
      (let ((vec (make-vector len)))
        (let ((env (ambiente-extendido-ejecutado proc-names vec old-env)))
          (for-each
            (lambda (pos ids body)
              (vector-set! vec pos (cerradura ids body env)))
            (iota len) idss bodies)
          env)))))



;iota: number -> list
;función que retorna una lista de los números desde 0 hasta end
(define iota
  (lambda (end)
    (let loop ((next 0))
      (if (>= next end) '()
        (cons next (loop (+ 1 next)))))))

;Funciones auxiliares para encontrar la posición de un símbolo en la lista de símbolos de un ambiente
(define list-find-position
  (lambda (sym los)
    (list-index (lambda (sym1) (eqv? sym1 sym)) los)))

(define list-index
  (lambda (pred ls)
    (cond
      ((null? ls) #f)
      ((pred (car ls)) 0)
      (else (let ((list-index-r (list-index pred (cdr ls))))
              (if (number? list-index-r)
                (+ list-index-r 1)
                #f))))))






;----------Implementando procedimientos
(define-datatype procVal procVal?
  (cerradura
   (lista-ID (list-of symbol?))
   (exp expresion?)
   (amb ambiente?)))
                     
(define aplicar-procedimiento
  (lambda (proc args)
    (cases procVal proc
      (cerradura (lista-ID exp amb)
               (evaluar-expresion exp (ambiente-extendido lista-ID args amb))))))




;----------Implementando variables mutables e inmutables
(define-datatype reference reference?
  (a-ref (position integer?)
         (vec vector?)))

(define deref
  (lambda (ref)
    (primitive-deref ref)))

(define primitive-deref
  (lambda (ref)
    (cases reference ref
      (a-ref (pos vec)
             (vector-ref vec pos)))))

(define setref!
  (lambda (ref val)
    (primitive-setref! ref val)))

(define primitive-setref!
  (lambda (ref val)
    (cases reference ref
      (a-ref (pos vec)
             (vector-set! vec pos val)))))

(define
  variables-constantes '())





;----------Implementando Diccionarios
(define dict?
  (lambda (expresion)
  (cond ((null? expresion) #f)
        ((list? expresion)
         (let ((len (length expresion)))
               
          (and (= len 2) (vector? (car expresion)) 
               (vector? (cadr expresion)))))
          (else #f))))


; reverse : list -> list
; usage : (reverse L) : la lista L ordenada de manera contraria
(define reverse
  (lambda (L)
    (if (null? L)
        '()
        (append (reverse (cdr L)) (list (car L))))))



; ;===================================================================================================
;----------Ejecutando el interpretador
(define pretty-print-value
  (lambda (val)
    (cond
      ((string? val) val)
      ((eqv? val 'void) #f)
      ((number? val) 
       (if (and (inexact? val) (integer? val))
           (inexact->exact val)  ;; Convertir 1.0 a 1 para impresión más limpia
           val))
      ((and (pair? val) (eq? (car val) 'tuple))
       (cons 'tuple (map pretty-print-value (cdr val))))
      ((list? val) (cons 'list (map pretty-print-value val)))
      ((and (list? val) (pair? (car val)) (not (eq? (caar val) 'tuple)) (not (eq? (caar val) 'list)))
       (cons 'dict (map (lambda (p) (cons (car p) (pretty-print-value (cdr p)))) val)))
      (else val))))


(define all-test
  (list
  ; ; Numeros
  "3"
  "24"
  "125"

  "3.14"
  "2.71"
  "45.6"

  "-2"
  "-25"
  "-546"

  "-2.3"
  "-25.31"
  "-712.334"

  ; ; cadenas
  "\"HolaMundo\""
  "\"FLP\""
  "\"Univalle\""

  ; ; booleanos
  "false"
  "true"

  ; ; false, 0 y null son falsos
  "if false then +(1,2) else +(4,5) done"
  "if 0 then +(1,2) else +(4,5) done"
  "if null then +(1,2) else +(4,5) done"



  ; ; listas
  "list ()"
  "list (1,2,3)"
  "list (list (1,2,3) , list (2,2,2))"
  "list (list (\"ola\",\"adios\",\"hi\") , list (-2,2.4,22))"



  ; ; diccionarios
  "dict (@a: 1, @b: 2, @c: 3, @d: 4, @e: 5)"



  ; ; primitivas booleas
  "[10 <  2]"
  "[10 >  2]"
  "[10 <= 2]"
  "[10 >= 2]"
  "[10 == 2]"
  "[10 != 2]"
  "[[8 == 4] and [3 > 2]]"
  "[[8 == 4] or  [3 > 2]]"
  "not [10 >  2]"



  ; ; primitivas numeros reales
  ;Pruebas enteros positivos
  "+(5,3)"
  "~(10,4)"
  "*(7,6)"
  "/(20,5)"
  "mod(20,3)"
  "add1(9)"
  "sub1(12)"
  ;Pruebas flotantes positivos
  "+(3.5,2.1)"
  "~(10.0,0.25)"
  "*(1.2,4.8)"
  "/(9.6,3.2)"
  "mod(20.4,3.2)"
  "add1(5.75)"
  "sub1(8.33)"
  ;Pruebas enteros negativos
  "+(-4,-6)"
  "~(-10,-3)"
  "*(-7,2)"
  "/(-20,4)"
  "mod(-43,5)"
  "add1(-9)"
  "sub1(-12)"
  ;Pruebas flotantes negativos
  "+(-3.3,-1.7)"
  "~(-8.5,-2.5)"
  "*(-2.2,3.0)"
  "/(-9.0,1.5)"
  "mod(-43.89,5.2)"
  "add1(-4.75)"
  "sub1(-6.99)"


  ; ; primitivas complejos



  ; ; primitivas cadenas
  "longitud(\"hola\")"
  "concat(\"cadena\", \"hola\")"



  ; ; primitivas listas
  "vacio"
  "vacio?(vacio)"
  "vacio?(list(1,2,3))"

  "crear-lista(list(4,5,6), 5)"
  "crear-lista(list(7,8,9), list (5))"

  "lista?(list (1,2,3,4,5))"
  "lista?(2)"

  "cabeza(list (1,2,3,4,5))"

  "cola(list (1,2,3,4,5))"

  "append(list (1,2,3,4,5) , list(6,7,8))"

  "ref-list(list(1,2,3), 1)"

  "set-list(list(1, 2, 3), 1, 99)"



  ; ; primitivas diccionarios
  "dict?(dict (@a: 1, @b: 2, @c: 3, @d: 4, @e: 5))"
  "dict?(list (1,2,3))"

  "crear-dict(dict (@a: 1, @b: 2, @b: 3), @c, 4 )"

  "ref-dict(dict (@a: 1, @b: 2, @b: 3), @b )"
  "ref-dict(dict (@a: 1, @b: 2, @b: 3), @h )"

  "set-dict(dict (@a: 1, @b: 2, @b: 3), @b, 4 )"

  "claves-dict(dict (@a: 1, @b: 2, @c: 3, @d: 4, @e: 5))"

  "valores-dict(dict (@a: 1, @b: 2, @c: 3, @d: 4, @e: 5))"



  ; ; estuctura de control
  ;If
  "if [10 > 2] then *(20, 2) else /(20, 2)  done"
  "if [10 == 2] then *(20, 2) else /(20, 2)  done"
  ;Swicth



  ; ; Iteracion
  ;for
  "for @i =1 to 10 do print(@i)done"
  ;While
  "var (@i = 1){while [@i <= 5] do begin print(@i);set @i = add1(@i) end done}"




  ; ; funciones
  "func-rec
    @fact(@n) = if [@n != 0]
        then *(@n , evaluar @fact(sub1(@n)) finEval)
        else 1 done
    {evaluar @fact(10) finEval}"
            


  ; ; recursivas
  "var(
      @sumar = func(@x, @y) {
      +(@x, @y) }
  ){
    evaluar @sumar(2,3) finEval
  }" 



  ; ; Begin
  "begin
    @a
  end"
  ))

(define run-all-tests
  (lambda ()
    (display "=== TODAS LAS PRUEBAS ===") (newline) (newline)
    (for-each
     (lambda (test)
       (display "Ejecutando: ") (display test) (newline)
       (display "Resultado:") (newline)
       (let* ((pgm (scan&parse test))
              (result (evaluar-programa pgm)))
         (display "Valor retornado: ")
         (display (pretty-print-value result))
         (newline)
         (display "---") (newline) (newline)))
     all-test)))

;(define resultados (run-all-tests))


(interpretador)
